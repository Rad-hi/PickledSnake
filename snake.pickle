;; I recommend a Lisp mode for your LSP for minimal text highlighting 

( load "/home/rs/Desktop/PickledSnake/raylib_bindings.pickle" )

( def {ZOZINGRAY}    (list 22 22 22 255) )
( def {RAYWHITE}     (list 245 245 245 255) )
( def {PICKLEGREEN}  (list 133 161 106 255) )
( def {MYPINK}       (list 189 88 110 255) )

( def {BG_COLOR} ZOZINGRAY )
( def {SNAKE_COLOR} PICKLEGREEN )
( def {FOOD_COLOR} MYPINK )
( def {TXT_COLOR} RAYWHITE )
( def {BIG_FONT_SZ} 32 )
( def {SML_FONT_SZ} 18 )

( def {FPS} 30 )
( def {TITLE} "PickledSnake" )
( def {WIN_WIDTH} 440 )
( def {WIN_HEIGHT} 400 )

( def {CANVAS_WIDTH} 400 )
( def {CANVAS_HEIGHT} 400 )
( def {N_COLS} 20 )
( def {N_ROWS} 20 )
( def {CELL_W} (/ CANVAS_WIDTH N_COLS))
( def {CELL_H} (/ CANVAS_HEIGHT N_ROWS))

( def {step_dt} .2 )  ;; [sec] smaller -> faster snake
( def {prev_ts} 0.0 )
( def {now_ts} 0.0 )

( def {game_over} false )

( def {over_msg} "GAME 0VER" )
( def {over_x} (/ CANVAS_WIDTH 4) )
( def {over_y} (/ (- CANVAS_HEIGHT BIG_FONT_SZ) 2) )

( def {start_msg} "press right arrow to start!" )
( def {start_x} (/ CANVAS_WIDTH 5) )
( def {start_y} (/ (+ CANVAS_HEIGHT SML_FONT_SZ) 2) )

( def {exit_msg} "press Esc to exit!" )
( def {exit_x} (/ (- CANVAS_WIDTH 160 ) 2) )
( def {exit_y} (/ (+ CANVAS_HEIGHT (* 2 BIG_FONT_SZ)) 2) )

( def {food_exists} false )
( def {food_x} 0 )
( def {food_y} 0 )

( def {head_x} 0 )
( def {head_y} 0 )
( def {tail_x} 0 )
( def {tail_y} 0 )
( def {dir_x} 1.0 )  ;; [0/1] indicates whether we're moving in axis
( def {dir_y} 0.0 )  ;; [+/-] indicates the direction

( def {xs} ( list head_x ) )
( def {ys} ( list head_y ) )


( fn {check_key_presses _} {
    ;; TODO: use `GetKeyPressed` to read all the queued key presses and update one at a time
    ( if (and (== (IsKeyPressed KEY_RIGHT) 1) (> dir_x -1.0)) { ( def {dir_x} (+ 1.0) ) ( def {dir_y} 0.0 ) } { nil } )
    ( if (and (== (IsKeyPressed KEY_LEFT) 1) (< dir_x 1.0)) { ( def {dir_x} (- 1.0) ) ( def {dir_y} 0.0 ) } { nil } )
    ( if (and (== (IsKeyPressed KEY_DOWN) 1) (> dir_y -1.0)) { ( def {dir_y} (+ 1.0) ) ( def {dir_x} 0.0 ) } { nil } )
    ( if (and (== (IsKeyPressed KEY_UP) 1) (< dir_y 1.0)) { ( def {dir_y} (- 1.0) ) ( def {dir_x} 0.0 ) } { nil } )
})


( fn { step _ } {
    (= {step_x} ( cast (* CELL_W dir_x) Int ))
    (= {step_y} ( cast (* CELL_H dir_y) Int ))
    ( def {head_x} (+ head_x step_x) )
    ( def {head_y} (+ head_y step_y) )
    ( def {tail_x} ( st xs ) )
    ( def {tail_y} ( st ys ) )

    (
        if (and (== food_x head_x) (== food_y head_y))
        {
            ( def {xs} ( join xs ( list head_x )) )
            ( def {ys} ( join ys ( list head_y )) )
            ( def {food_exists} false )
        }
        { 
            ( def {xs} ( join ( tail xs ) ( list head_x )) )
            ( def {ys} ( join ( tail ys ) ( list head_y )) )
        }
    )

    ( def {prev_ts} now_ts )
})


( fn { spawn_food _ } {
    (= {x} (* CELL_W ( GetRandomValue 0 (- N_COLS 1) )) )
    (= {y} (* CELL_H ( GetRandomValue 0 (- N_ROWS 1) )) )
    (
        if (and (not (in x xs)) (not (in y ys)))
        {( def {food_x} x ) ( def {food_y} y )}
        {( spawn_food {} )}  ;; TODO: do better! might (will) produce an infinite loop
    )
    ( def {food_exists} true )
})


( fn {is_self_collision xs_ ys_} {
    if (== xs_ nil)
    {false}
    {
        if (and (== head_x (st xs_)) (== head_y (st ys_))) 
        {true}
        {is_self_collision (tail xs_) (tail ys_)}
    }
})


( fn { is_over _ } {
    (
        = {out_of_bounds} (or (or (>= head_x CANVAS_WIDTH) (< head_x 0)) 
                              (or (>= head_y CANVAS_HEIGHT) (< head_y 0)))
    )

    (= {dacapitated_len} (- ( len xs ) 1) )
    (= {dacapitated_xs} ( take dacapitated_len xs ) )
    (= {dacapitated_ys} ( take dacapitated_len ys ) )
    (
        if (or out_of_bounds ( is_self_collision dacapitated_xs dacapitated_ys ))
        {
            ( def {game_over} true )
        }
        { nil }
    )
})


( fn { loop func } {

    if (== ( func {} ) 1)
    { nil }
    {
        ;; TODO: make the game only start when the user presses the right arrow
        ;; TODO: add pause/unpause game

        ( def {now_ts} ( GetTime {} ) )
        ( BeginDrawing {} )
            ( DrawRectangleLines 1 1 (- CANVAS_WIDTH 1) (- CANVAS_HEIGHT 1) TXT_COLOR )

            ( if ( game_over )
                {
                    ( DrawText over_msg over_x over_y BIG_FONT_SZ TXT_COLOR )
                    ( DrawText exit_msg exit_x exit_y SML_FONT_SZ TXT_COLOR )
                    ; TODO: ask for rematch
                }
                {
                    ( is_over {} )

                    ;; the length of the snake represents the score
                    ( let {
                        (= {score_str} ( cast ( len xs ) String ))
                        (= {x} (+ CANVAS_WIDTH 10))
                        (= {y} 10)
                        (= {pad} 5)
                        ( DrawRectangle x y CELL_W CELL_H BG_COLOR )
                        ( DrawText score_str (+ x pad) (+ y pad) SML_FONT_SZ TXT_COLOR )
                    })

                    ( if (food_exists)
                        { nil }
                        {
                            ( DrawRectangle food_x food_y CELL_W CELL_H BG_COLOR )
                            ( spawn_food {} )
                            ( DrawRectangle food_x food_y CELL_W CELL_H FOOD_COLOR )
                        }
                    )

                    ;; minimizing the rectangles to be drawn by only drawing the head and tail
                    ;; has a side effect of a shadow background colored box
                    ;; (could be seen when "walking" on the walls)
                    ( DrawRectangle tail_x tail_y CELL_W CELL_H BG_COLOR )
                    ( DrawRectangle head_x head_y CELL_W CELL_H SNAKE_COLOR )

                    ( if (>= (- now_ts prev_ts) step_dt ) {( step {} )} { nil } )
                    ( check_key_presses {} )
                }
            )

        ( EndDrawing {} )
        ( loop func )
    }
})


( InitWindow WIN_WIDTH WIN_HEIGHT TITLE )
( ClearBackground BG_COLOR )
( SetTargetFPS FPS )
( loop WindowShouldClose )
( CloseWindow {} )
